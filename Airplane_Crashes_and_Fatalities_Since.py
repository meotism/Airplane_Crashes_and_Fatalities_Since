# -*- coding: utf-8 -*-
"""DoAnThucHanh#1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e6wiyt1yHhpOVz2VcOHxKqFTQyoMz-Fb

1. Tìm hiểu và mô tả ý nghĩa các biến trong tập dữ liệu.
2. Thống kê mô tả và vẽ biểu đồ phân phối trên các trường của tập dữ liệu này.
Đánh giá sơ bộ về tính chất phân phối của các biến.
3. Phân chia tập train/test và lựa chọn metric cho bài toán.
4. Xây dựng model, triển khai và đánh giá mô hình
"""

#B1: loading data
import numpy as np
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
from datetime import date, timedelta, datetime
from google.colab import files
uploaded = files.upload()
df=pd.read_csv('Airplane_Crashes_and_Fatalities_Since_1908.csv')
df.head()

"""Câu 1: Tìm hiểu và mô tả các trường dữ liệu

Date: Ngày diễn ra tai nạn - datetime

Time: Thời gian diễn ra tai nạn - time

Location: Địa điểm diễn ra tai nạn - string

Operator: Tổ chức thực hiện chuyến bay - string

Flight# : Số hiệu chuyến bay - string

Route: Mục đích chuyến bay - string

Type: Loại máy bay - string

Registration: Đã đăng ký bay chưa? - stirng

cn/In : số hiệu nhà sản xuất - string

Abroad: Số người bị thương máy ban - int

Fatalies: Số người tử vong - int

Ground: Số người chết ở trên mặt đất - int

Summary: Tóm tắt diễn biến đã xảy ra và nguyên nhân gây ra tai nạn - string



"""

#cleaning df (mục đích tạo ra dòng mới với format=Date+Time, Thế các dữ liệu NaN trong cột time thành 0:00, Đồng thời xóa các kí hiệu thừa)// sử dụng cho data cũ
df['Time'] = df['Time'].replace(np.nan, '00:00') 
df['Time'] = df['Time'].str.replace('c: ', '')
df['Time'] = df['Time'].str.replace('c:', '')
df['Time'] = df['Time'].str.replace('c', '')
df['Time'] = df['Time'].str.replace('12\'20', '12:20')
df['Time'] = df['Time'].str.replace('18.40', '18:40')
df['Time'] = df['Time'].str.replace('0943', '09:43')
df['Time'] = df['Time'].str.replace('22\'08', '22:08')
df['Time'] = df['Time'].str.replace('114:20', '00:00') 

df['Time'] = df['Date'] + ' ' + df['Time'] 
def todate(x):
    return datetime.strptime(x, '%m/%d/%Y %H:%M')
df['Time'] = df['Time'].apply(todate) 
print('Date ranges from ' + str(df.Time.min()) + ' to ' + str(df.Time.max()))

df.Operator = df.Operator.str.upper() #tránh trùng lắp dữ liệu

#B2: Exploring data
df.describe()

"""Count là số lượng dòng của các cột cụ thể là các cột

Mean là giá trị trung bình mỗi cột

std là độ lệch chuẩn của mỗi cột

min là giá trị nhỏ nhất của mỗi cột

25% là thể hiện 25% giá trị nhỏ hơn ở các cột

50%,75% tương tự 25%

max là giá lớn nhất trong các cột
"""

df.info()

"""Tập dữ liệu chứa 13 cột, Aboard, Fatalities, Ground  là target variable, trong khi tất cả các cột khác là các tính năng của tập dữ liệu.

> Indented block





"""

#B3: Preprocessing the Dataset
df.dtypes
df.isnull().sum().sort_values(ascending=False)

df.isnull().sum().sort_values(ascending=False)
for column in df.columns:
  percent=df[column].isnull().mean()
  print(f'{column}:{round(percent*100,3)}')

"""Các cột hầu như missing data. Chỉ có cột Date và Time không missing data


"""

#xoa cot missing data nhieu
df.drop(['Flight #'],axis = 1,inplace= True)

plt.rcParams["figure.figsize"] = [10, 6]
df.count().plot(kind="bar")

#ffill là điền phần tử có giá trị từ dòng trước vào dòng sau có giá trị null bfill là ngược lại
df.fillna(method='ffill', inplace= True)
df.fillna(method='bfill', inplace= True)
df.dtypes
df.isnull().sum().sort_values(ascending=False)

sum(df.duplicated())

"""Không có dữ liệu trùng

Vì data không có các đủ các trường dữ liệu thống kê quan trong nên ta sẽ skip phần kiểm tra outlier
"""

# Tạo một dataframe temp chứa thông tin của df và tách cột operator chia thành 2 loại Military và Passenger
#Câu 2:
Temp = df.copy()
Temp['isMilitary'] = Temp.Operator.str.contains('MILITARY')
Temp = Temp.groupby('isMilitary')[['isMilitary']].count()
Temp.index = ['Passenger', 'Military']
Temp2 = df.copy()
Temp2['Military'] = Temp2.Operator.str.contains('MILITARY')
Temp2['Passenger'] = Temp2.Military == False
Temp2 = Temp2.loc[:, ['Time', 'Military', 'Passenger']]
Temp2 = Temp2.groupby(Temp2.Time.dt.year)[['Military', 'Passenger']].aggregate(np.count_nonzero)
colors = ['yellowgreen', 'lightskyblue']
plt.figure(figsize=(15,6))
plt.subplot(1, 2, 1)
patches, texts = plt.pie(Temp.isMilitary, colors=colors, labels=Temp.isMilitary, startangle=90)
plt.legend(patches, Temp.index, loc="best", fontsize=10)
plt.axis('equal')
plt.title('Total number of accidents by Type of flight', loc='Center', fontsize=14)

# %%
plt.subplot(1, 2, 2)
plt.plot(Temp2.index, 'Military', data=Temp2, color='lightskyblue', marker = ".", linewidth=1)
plt.plot(Temp2.index, 'Passenger', data=Temp2, color='yellowgreen', marker = ".", linewidth=1)
plt.legend(fontsize=10)
plt.xlabel('Year', fontsize=10)
plt.ylabel('Count', fontsize=10)
plt.title('Count of accidents by Year', loc='Center', fontsize=14)
plt.tight_layout()
plt.show()

#Câu 3:
import pandas as pd
import numpy as np
a=pd.read_csv('train.csv')
b=pd.read_csv('test.csv')
a.info()

b.info()

#Drop cột severity, accident_ID
a.drop(['Severity'],axis=1, inplace=True)
a.drop(['Accident_ID'],axis=1, inplace=True)

#Sau khi dữ liệu đã được làm sạch, các cột tập dữ liệu có thể được tách thành cột tính năng và cột mục tiêu.(làm trên train)
Xtrain = a.iloc[:,a.columns != 'Safety_Score']#independ
ytrain = a.Safety_Score #depend

#tập dữ liệu có thể được chia thành các tập huấn luyện và thử nghiệm. 
#Tập huấn luyện được sử dụng để huấn luyện trình phân loại, trong khi tập kiểm tra có thể được sử dụng để đánh giá hiệu suất của trình phân loại trên các trường hợp không nhìn thấy.
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from matplotlib import pyplot as plt
from sklearn.linear_model import LogisticRegression

#Chia dữ liệu train & test: 80:20
X_train, X_test, y_train, y_test = train_test_split(Xtrain, ytrain, test_size=0.20, random_state=0)

#Xây dựng model
model = LogisticRegression()

#Tạo standard x scaler
scaler = preprocessing.StandardScaler().fit(X_train)
X_train_scaled = scaler.transform(X_train)

#Training the model
model.fit(X_train_scaled, y_train.astype('int'))

#đánh giá mô hình trên training set và xem kết quả:
train_acc = model.score(X_train_scaled, y_train.astype('int'))
print("The Accuracy for Training Set is {}".format(train_acc*100))

##Độ chính xác chỉ có 5,4625%, khá thấp, nhưng độ chính xác khi training không hữu ích lắm, độ chính xác của test mới là thực sự của thành công.

#Sau khi dữ liệu đã được làm sạch, các cột tập dữ liệu có thể được tách thành cột tính năng và cột mục tiêu.(làm trên test)
Xtest = b.iloc[:,b.columns != 'Safety_Score']#independ
ytest = b.Safety_Score #depend

#Chia dữ liệu train & test: 80:20
X_train, X_test, y_train, y_test = train_test_split(Xtrain, ytrain, test_size=0.20, random_state=0)

#Tạo standard x scaler
scaler = preprocessing.StandardScaler().fit(X_train)
X_train_scaled = scaler.transform(X_train)

#Training the model
model.fit(X_train_scaled, y_train.astype('int'))

lm = LogisticRegression(solver='lbfgs',random_state=0)
lm.fit(X_train, y_train.astype('int'))
y_pred = lm.predict(X_test)
y_pred

#đánh giá mô hình trên test set và xem kết quả:
test_acc = accuracy_score(y_test.astype('int'), y_pred)
print("The Accuracy for Test Set is {}".format(test_acc*100))

##Độ chính xác chỉ có 2.7%, mức độ dự đoán điểm an toàn thấp.

#Câu 4:
import pandas as pd
import numpy as np
from google.colab import files
uploaded = files.upload()
uploaded_2=files.upload()
x=pd.read_csv('train.csv')
y=pd.read_csv('test.csv')
frames=[x,y]
df=pd.concat(frames)
df.info()

df.describe().drop('Accident_ID', axis=1)

#Drop cột severity, cột Accident_ID
df=df.drop(['Severity', 'Accident_ID'],axis=1)
df.info()

#Phân chia tập train,test
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(df.iloc[:, :-1],df.iloc[:,-1],test_size =0.25)
print("train data shape of X=%s and Y =%s :"%(x_train.shape,y_train.shape))
print("test data shape of X=%s and Y =%s :"%(x_test.shape,y_test.shape))

result={'Linear Regression':[],'Ridge Regression':[],'CV Ridge Regression':[]}
result['Metrics']=['R2_train','MSE_train','R2_test','MSE_test']

#Lấy kết quả đánh giá
def get_results (model,X,y,key):
    score=model.score(X,y)
    y_pred=model.predict(X)
    if (key=='CV Regression' or key=='CV Lasso Regression'):
        print('Lamda: ',model.alpha_)
    print('Intercept: ', model.intercept_)
    coefficients=pd.DataFrame()
    coefficients["Columns"]=X.columns
    coefficients["Coefficients Estimate"]=pd.Series(model.coef_)
    print(coefficients)
    print('R2: ',score)
    mean_squared_error=np.mean((y_pred - y)**2)
    print('MSE: ',mean_squared_error)
    result[key].append(score)
    result[key].append(mean_squared_error)
    return score,mean_squared_error

#Xây dựng mô hình với linear regression
from sklearn.linear_model import LinearRegression
lreg = LinearRegression()
lreg.fit(x_train, y_train)
print("Đánh giá trên tập train")
print("=======================")
get_results(lreg,x_train,y_train,'Linear Regression')

# %%
print("Đánh giá trên tập test")
print("=======================")
get_results(lreg,x_test,y_test,'Linear Regression')

#Xây dựng mô hình với cross-validation
from sklearn.linear_model import Ridge
from sklearn.linear_model import RidgeCV
from numpy import arange
from sklearn.model_selection import RepeatedKFold
cv=RepeatedKFold(n_splits=10,n_repeats=3,random_state=1)
RidgeCV=RidgeCV(alphas=arange(0,1,0.01),cv=cv,scoring='neg_mean_absolute_error')
RidgeCV.fit(x_train,y_train)
print("Đánh giá trên tập train")
print("=======================")
get_results(RidgeCV,x_train,y_train,'CV Ridge Regression')

print("Đánh giá trên tập test")
print("=======================")
get_results(RidgeCV,x_test,y_test,'CV Ridge Regression')

#Xây dựng mô hình với Ridge với lamda=1
from sklearn.linear_model import Ridge
ridgeR=Ridge(alpha=1)
ridgeR.fit(x_train,y_train)
#Dự đoán trên tập train
print("Đánh giá trên tập train")
print("=======================")
get_results(ridgeR,x_train,y_train,'Ridge Regression')

#Dự đoán trên tập test
print("Đánh giá trên tập train")
print("=======================")
get_results(ridgeR,x_test,y_test,'Ridge Regression')

df=pd.DataFrame(result,columns=['Metrics','Linear Regression','Ridge Regression','CV Ridge Regression'])
print(df)

#Nhận xét:
# Ta thấy rằng tập test luôn cho kết quả nhỏ hơn tập train
# Phương pháp cho R2 cao nhất là của Linear Regression (R2_test cao nhất. MSE_Test thấp nhất)
# Ở dataset này, ta thấy được việc cho lamda=1 và tự chon lamda đều cho kết quả như nhau
# Các kết luận trên chỉ đúng với dataset ở trên